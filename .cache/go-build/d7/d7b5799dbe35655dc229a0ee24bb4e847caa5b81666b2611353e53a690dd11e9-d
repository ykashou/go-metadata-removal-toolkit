//line /workspace/src/processor/processor.go:1:1
package processor

import (
	"errors"
	"fmt"
	"path/filepath"
	"strings"

	"metadata-remover/src/logger"
	"metadata-remover/src/stats"
	"metadata-remover/src/utils"
)

// Processor handles metadata removal from various file types
type Processor struct {
	logger      *logger.Logger
	previewMode bool
	Stats       *stats.MetadataStats
}

// Using file type constants from stats package

// NewProcessor creates a new processor
func NewProcessor(logger *logger.Logger, previewMode bool) *Processor {goCover_72deca207aa4__17[0] = 1 ; goCover_72deca207aa4__17[1] = goCover_72deca207aa4_P ; goCover_72deca207aa4__17[2] = 17 ; goCover_72deca207aa4__17[3] = 1;
	return &Processor{
		logger:      logger,
		previewMode: previewMode,
		Stats:       stats.NewMetadataStats(),
	}
}

// ProcessFile processes a file based on its extension
func (p *Processor) ProcessFile(filePath, ext string) error {goCover_72deca207aa4__18[0] = 12 ; goCover_72deca207aa4__18[1] = goCover_72deca207aa4_P ; goCover_72deca207aa4__18[2] = 18 ; goCover_72deca207aa4__18[3] = 1;
	// Determine file type based on extension
	fileType := p.getFileType(ext)

	if fileType == stats.TypeUnknown {goCover_72deca207aa4__18[8] = 1;
		p.logger.Warning("Unsupported file type: %s", ext)
		utils.PrintWarning(fmt.Sprintf("Unsupported file type: %s (skipping %s)", ext, filepath.Base(filePath)))
		return errors.New("unsupported file type")
	}

	// Track file in statistics
	goCover_72deca207aa4__18[4] = 1;p.Stats.AddFile(fileType)

	// Process file based on type
	var err error
	switch fileType {
	case stats.TypeImage:goCover_72deca207aa4__18[9] = 1;
		err = p.ProcessImage(filePath, ext)
	case stats.TypePDF:goCover_72deca207aa4__18[10] = 1;
		err = p.ProcessPDF(filePath)
	case stats.TypeDocument:goCover_72deca207aa4__18[11] = 1;
		err = p.ProcessDocument(filePath, ext)
	}

	goCover_72deca207aa4__18[5] = 1;if err != nil {goCover_72deca207aa4__18[12] = 1;
		return err
	}

	goCover_72deca207aa4__18[6] = 1;if p.previewMode {goCover_72deca207aa4__18[13] = 1;
		p.logger.Info("Preview mode: Would process %s", filePath)
		utils.PrintInfo(fmt.Sprintf("Preview mode: Would remove metadata from %s", filepath.Base(filePath)))
	} else{ goCover_72deca207aa4__18[14] = 1;{
		p.logger.Success("Successfully removed metadata from %s", filePath)
		utils.PrintSuccess(fmt.Sprintf("Successfully removed metadata from %s", filepath.Base(filePath)))
	}}

	goCover_72deca207aa4__18[7] = 1;return nil
}

// getFileType determines the file type based on extension
func (p *Processor) getFileType(ext string) string {goCover_72deca207aa4__19[0] = 9 ; goCover_72deca207aa4__19[1] = goCover_72deca207aa4_P ; goCover_72deca207aa4__19[2] = 19 ; goCover_72deca207aa4__19[3] = 1;
	ext = strings.ToLower(ext)

	// Image file extensions
	imageExtensions := []string{".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".tif", ".webp"}
	for _, imgExt := range imageExtensions {goCover_72deca207aa4__19[7] = 1;
		if ext == imgExt {goCover_72deca207aa4__19[8] = 1;
			return stats.TypeImage
		}
	}

	// PDF file extension
	goCover_72deca207aa4__19[4] = 1;if ext == ".pdf" {goCover_72deca207aa4__19[9] = 1;
		return stats.TypePDF
	}

	// Document file extensions
	goCover_72deca207aa4__19[5] = 1;docExtensions := []string{".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx", ".odt", ".ods", ".odp", ".rtf", ".txt"}
	for _, docExt := range docExtensions {goCover_72deca207aa4__19[10] = 1;
		if ext == docExt {goCover_72deca207aa4__19[11] = 1;
			return stats.TypeDocument
		}
	}

	goCover_72deca207aa4__19[6] = 1;return stats.TypeUnknown
}
