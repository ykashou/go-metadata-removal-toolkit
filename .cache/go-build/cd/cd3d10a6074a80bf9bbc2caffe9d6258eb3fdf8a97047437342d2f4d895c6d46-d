//line /workspace/src/scanner/scanner.go:1:1
package scanner

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"

	"metadata-remover/src/logger"
	"metadata-remover/src/processor"
	"metadata-remover/src/stats"
	"metadata-remover/src/utils"
)

// Scanner handles the file scanning and processing
type Scanner struct {
	logger      *logger.Logger
	previewMode bool
	verbose     bool
	processor   *processor.Processor
}

// NewScanner creates a new scanner instance
func NewScanner(logger *logger.Logger, previewMode, verbose bool) *Scanner {goCover_6afb00e08b12__0[0] = 1 ; goCover_6afb00e08b12__0[1] = goCover_6afb00e08b12_P ; goCover_6afb00e08b12__0[2] = 0 ; goCover_6afb00e08b12__0[3] = 1;
	return &Scanner{
		logger:      logger,
		previewMode: previewMode,
		verbose:     verbose,
		processor:   processor.NewProcessor(logger, previewMode),
	}
}

// ScanDirectory recursively scans a directory and processes files
func (s *Scanner) ScanDirectory(dirPath string, recursive bool) (int, int, error) {goCover_6afb00e08b12__1[0] = 12 ; goCover_6afb00e08b12__1[1] = goCover_6afb00e08b12_P ; goCover_6afb00e08b12__1[2] = 1 ; goCover_6afb00e08b12__1[3] = 1;
	fileCount := 0
	processedCount := 0

	walkFunc := func(path string, info fs.FileInfo, err error) error {goCover_6afb00e08b12__1[6] = 1;
		if err != nil {goCover_6afb00e08b12__1[10] = 1;
			s.logger.Error("Error accessing path %s: %v", path, err)
			utils.PrintError(fmt.Sprintf("Error accessing path %s: %v", path, err))
			return nil // Continue walking even if there's an error accessing a path
		}

		// Skip directories in non-recursive mode
		goCover_6afb00e08b12__1[7] = 1;if !recursive && info.IsDir() && path != dirPath {goCover_6afb00e08b12__1[11] = 1;
			return filepath.SkipDir
		}

		// Skip directories and process files
		goCover_6afb00e08b12__1[8] = 1;if !info.IsDir() {goCover_6afb00e08b12__1[12] = 1;
			fileCount++
			err := s.ProcessFile(path)
			if err == nil {goCover_6afb00e08b12__1[13] = 1;
				processedCount++
			}
		}
		goCover_6afb00e08b12__1[9] = 1;return nil
	}

	// Start walking
	goCover_6afb00e08b12__1[4] = 1;err := filepath.Walk(dirPath, walkFunc)
	if err != nil {goCover_6afb00e08b12__1[14] = 1;
		return fileCount, processedCount, err
	}

	goCover_6afb00e08b12__1[5] = 1;return fileCount, processedCount, nil
}

// ProcessFile processes a single file
func (s *Scanner) ProcessFile(filePath string) error {goCover_6afb00e08b12__2[0] = 11 ; goCover_6afb00e08b12__2[1] = goCover_6afb00e08b12_P ; goCover_6afb00e08b12__2[2] = 2 ; goCover_6afb00e08b12__2[3] = 1;
	// Get file info
	_, err := os.Stat(filePath)
	if err != nil {goCover_6afb00e08b12__2[7] = 1;
		s.logger.Error("Error accessing file %s: %v", filePath, err)
		if s.verbose {goCover_6afb00e08b12__2[9] = 1;
			utils.PrintError(fmt.Sprintf("Error accessing file %s: %v", filePath, err))
		}
		goCover_6afb00e08b12__2[8] = 1;return err
	}

	// Get file extension and check if supported
	goCover_6afb00e08b12__2[4] = 1;ext := strings.ToLower(filepath.Ext(filePath))

	if s.verbose {goCover_6afb00e08b12__2[10] = 1;
		utils.PrintInfo(fmt.Sprintf("Processing file: %s", filePath))
	}

	// Process file based on extension
	goCover_6afb00e08b12__2[5] = 1;err = s.processor.ProcessFile(filePath, ext)
	if err != nil {goCover_6afb00e08b12__2[11] = 1;
		s.logger.Error("Error processing file %s: %v", filePath, err)
		if s.verbose {goCover_6afb00e08b12__2[13] = 1;
			utils.PrintError(fmt.Sprintf("Error processing file %s: %v", filePath, err))
		}
		goCover_6afb00e08b12__2[12] = 1;return err
	}

	goCover_6afb00e08b12__2[6] = 1;return nil
}

// GetStats returns the metadata statistics collected during processing
func (s *Scanner) GetStats() *stats.MetadataStats {goCover_6afb00e08b12__3[0] = 1 ; goCover_6afb00e08b12__3[1] = goCover_6afb00e08b12_P ; goCover_6afb00e08b12__3[2] = 3 ; goCover_6afb00e08b12__3[3] = 1;
	return s.processor.Stats
}
